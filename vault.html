<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vault</title>
    <link rel="stylesheet" href="frontend/theme.css">
    <!-- Icon Library -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Minimal override for non-theme critical stuff if needed, otherwise empty */
    </style>
</head>

<body>
    <!-- App Container -->
    <div class="app-container">
        <!-- 1. Activity Bar -->
        <div id="activity-bar" class="activity-bar">
            <!-- Icons injected here -->
        </div>

        <!-- 2. Side Panel -->
        <div id="side-panel" class="side-panel" style="position:relative;">
            <div class="side-panel-header">
                <span id="side-panel-title">EXPLORER</span>
            </div>
            <div id="side-panel-content" class="side-panel-content">
                <!-- Content injected here -->
            </div>
            <div id="side-panel-resize" class="side-panel-resize"></div>
        </div>

        <!-- 3. Main Editor (GoldenLayout) -->
        <div class="main-editor">
            <div id="layout-root" style="width:100%; height:100%;"></div>
        </div>
    </div>

    <script type="module">
        import { GoldenLayout } from 'golden-layout';
        import 'golden-layout/dist/css/goldenlayout-base.css';
        import 'golden-layout/dist/css/themes/goldenlayout-dark-theme.css';

        // --- Sidebar Manager ---
        class SidebarManager {
            constructor() {
                this.views = new Map(); // id -> { icon, title, content }
                this.activeViewId = null;

                this.barEl = document.getElementById('activity-bar');
                this.panelEl = document.getElementById('side-panel');
                this.titleEl = document.getElementById('side-panel-title');
                this.contentEl = document.getElementById('side-panel-content');
            }

            registerView(id, iconData, title) {
                console.log(`[SidebarManager] Registering view: ${id}, icon: ${iconData}, title: ${title}`);

                if (this.views.has(id)) {
                    console.log(`[SidebarManager] View ${id} already registered, skipping`);
                    return;
                }

                this.views.set(id, { icon: iconData, title: title, content: '' });

                // Create Icon Button
                const btn = document.createElement('div');
                btn.className = 'activity-action';
                btn.title = title;
                btn.onclick = () => this.toggle(id);
                btn.dataset.id = id;

                // Check if iconData looks like an SVG string, otherwise assume it's a Lucide name
                if (iconData.trim().startsWith('<')) {
                    btn.innerHTML = iconData;
                    console.log(`[SidebarManager] Using raw SVG for ${id}`);
                } else {
                    // Lucide Icon name
                    btn.innerHTML = `<i data-lucide="${iconData}"></i>`;
                    console.log(`[SidebarManager] Using Lucide icon "${iconData}" for ${id}`);
                }

                this.barEl.appendChild(btn);
                console.log(`[SidebarManager] Button appended to activity bar`);

                // Initialize icons if Lucide is available
                if (window.lucide) {
                    window.lucide.createIcons();
                    console.log(`[SidebarManager] Lucide icons initialized`);
                } else {
                    console.warn(`[SidebarManager] Lucide not available!`);
                }
            }

            setContent(id, html) {
                if (this.views.has(id)) {
                    this.views.get(id).content = html;
                    // Update if active
                    if (this.activeViewId === id) {
                        this.contentEl.innerHTML = html;
                    }
                }
            }

            toggle(id) {
                if (this.activeViewId === id) {
                    // Close
                    this.activeViewId = null;
                    this.panelEl.classList.remove('open');
                    this._updateIcons();
                } else {
                    // Open
                    this.activeViewId = id;
                    const view = this.views.get(id);
                    this.titleEl.textContent = view.title;
                    this.contentEl.innerHTML = view.content || '<div style="padding:20px; text-align:center; color:var(--text-disabled)">Loading...</div>';
                    this.panelEl.classList.add('open');
                    this._updateIcons();

                    // Request content update from plugin if empty
                    if (!view.content) {
                        // Optional: Emit event to plugin to load data
                        // window.request('execute_command', { command: `${id}.get_sidebar` });
                    }
                }

                // Resize GoldenLayout after transition
                setTimeout(() => {
                    if (window.myLayout) window.myLayout.updateSize();
                }, 150);
            }

            _updateIcons() {
                const btns = this.barEl.querySelectorAll('.activity-action');
                btns.forEach(btn => {
                    if (btn.dataset.id === this.activeViewId) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
            }
        }

        // --- Panel Manager (GoldenLayout tabs) ---
        class PanelManager {
            constructor() {
                this.panels = new Map(); // id -> { title, content, component }
            }

            registerPanel(id, title, icon = null, position = 'right') {
                console.log(`[PanelManager] Registering panel: ${id}, title: ${title}, position: ${position}`);

                if (this.panels.has(id)) {
                    console.log(`[PanelManager] Panel ${id} already registered`);
                    return;
                }

                this.panels.set(id, { title, icon, content: '', position });

                // Register component with GoldenLayout
                if (window.myLayout) {
                    // Register the component type if not already registered
                    try {
                        window.myLayout.registerComponent(`plugin_${id}`, (container, state) => {
                            container.element.innerHTML = `
                                <div class="panel-container" id="panel-${id}">
                                    <div class="scrollable" style="padding: 12px;">
                                        <div style="color:var(--text-disabled); text-align:center;">
                                            Loading ${title}...
                                        </div>
                                    </div>
                                </div>
                            `;
                        });
                    } catch (e) {
                        // Component already registered, which is fine
                    }

                    // Find target stack based on position
                    const root = window.myLayout.root;
                    if (root && root.contentItems && root.contentItems.length > 0) {
                        // Add to existing layout - find appropriate stack
                        const newItem = {
                            type: 'component',
                            componentName: `plugin_${id}`,
                            title: title,
                            id: id
                        };

                        // Try to add to existing right column stack
                        try {
                            const rightColumn = root.contentItems[0]?.contentItems?.[1];
                            if (rightColumn && rightColumn.contentItems) {
                                const stack = rightColumn.contentItems[0]; // First stack in right column
                                if (stack && stack.addChild) {
                                    stack.addChild(newItem);
                                    console.log(`[PanelManager] Added panel ${id} to layout`);
                                }
                            }
                        } catch (e) {
                            console.warn(`[PanelManager] Could not add panel to layout:`, e);
                        }
                    }
                }
            }

            setPanelContent(id, html) {
                console.log(`[PanelManager] Setting content for panel: ${id}`);
                if (this.panels.has(id)) {
                    this.panels.get(id).content = html;
                }

                // Update DOM if panel exists
                const panelEl = document.getElementById(`panel-${id}`);
                if (panelEl) {
                    panelEl.innerHTML = `<div class="scrollable" style="padding: 12px;">${html}</div>`;
                    // Re-init icons
                    if (window.lucide) window.lucide.createIcons();
                }
            }

            removePanel(id) {
                console.log(`[PanelManager] Removing panel: ${id}`);
                this.panels.delete(id);

                // Remove from GoldenLayout
                if (window.myLayout) {
                    const items = window.myLayout.root.getItemsById(id);
                    items.forEach(item => item.remove());
                }
            }
        }

        // --- Toolbar Manager ---
        class ToolbarManager {
            constructor() {
                this.buttons = new Map(); // id -> { icon, title, command }
                this._ensureToolbar();
            }

            _ensureToolbar() {
                // Create toolbar container if it doesn't exist
                if (!document.getElementById('plugin-toolbar')) {
                    const activityBar = document.getElementById('activity-bar');
                    if (activityBar) {
                        const separator = document.createElement('div');
                        separator.className = 'activity-separator';
                        separator.style.cssText = 'height:1px; background:var(--border-color); margin:8px 4px;';

                        const toolbar = document.createElement('div');
                        toolbar.id = 'plugin-toolbar';
                        toolbar.className = 'plugin-toolbar';

                        activityBar.appendChild(separator);
                        activityBar.appendChild(toolbar);
                    }
                }
            }

            registerButton(id, icon, title, command) {
                console.log(`[ToolbarManager] Registering button: ${id}, command: ${command}`);

                if (this.buttons.has(id)) {
                    console.log(`[ToolbarManager] Button ${id} already registered`);
                    return;
                }

                this.buttons.set(id, { icon, title, command });
                this._ensureToolbar();

                const toolbar = document.getElementById('plugin-toolbar');
                if (toolbar) {
                    const btn = document.createElement('div');
                    btn.className = 'activity-action toolbar-btn';
                    btn.title = title;
                    btn.dataset.id = id;
                    btn.dataset.command = command;
                    btn.innerHTML = `<i data-lucide="${icon}"></i>`;

                    btn.onclick = async () => {
                        console.log(`[ToolbarManager] Executing command: ${command}`);
                        try {
                            await window.request('execute_command', { command: command, args: {} });
                        } catch (e) {
                            console.error(`[ToolbarManager] Command failed:`, e);
                        }
                    };

                    toolbar.appendChild(btn);

                    if (window.lucide) window.lucide.createIcons();
                }
            }
        }

        // --- Modal Manager ---
        class ModalManager {
            constructor() {
                this.isOpen = false;
                this._ensureModal();
            }

            _ensureModal() {
                if (!document.getElementById('plugin-modal-overlay')) {
                    const overlay = document.createElement('div');
                    overlay.id = 'plugin-modal-overlay';
                    overlay.className = 'modal-overlay';
                    overlay.style.cssText = `
                        display: none;
                        position: fixed;
                        top: 0; left: 0; right: 0; bottom: 0;
                        background: rgba(0,0,0,0.6);
                        z-index: 1000;
                        justify-content: center;
                        align-items: center;
                    `;
                    overlay.innerHTML = `
                        <div id="plugin-modal" class="modal-dialog" style="
                            background: var(--surface-color);
                            border-radius: 8px;
                            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
                            max-height: 80vh;
                            overflow: hidden;
                            display: flex;
                            flex-direction: column;
                        ">
                            <div class="modal-header" style="
                                padding: 16px 20px;
                                border-bottom: 1px solid var(--border-color);
                                display: flex;
                                justify-content: space-between;
                                align-items: center;
                            ">
                                <h3 id="modal-title" style="margin:0; font-size:1rem;"></h3>
                                <button id="modal-close-btn" class="icon-btn" style="
                                    background: none; border: none; cursor: pointer;
                                    color: var(--text-secondary); font-size: 1.2rem;
                                ">&times;</button>
                            </div>
                            <div id="modal-content" class="modal-body" style="
                                padding: 20px;
                                overflow-y: auto;
                                flex: 1;
                            "></div>
                        </div>
                    `;

                    document.body.appendChild(overlay);

                    // Close handlers
                    overlay.onclick = (e) => {
                        if (e.target === overlay) this.close();
                    };
                    document.getElementById('modal-close-btn').onclick = () => this.close();
                }
            }

            show(title, html, width = '500px') {
                console.log(`[ModalManager] Showing modal: ${title}`);
                this._ensureModal();

                const overlay = document.getElementById('plugin-modal-overlay');
                const modal = document.getElementById('plugin-modal');
                const titleEl = document.getElementById('modal-title');
                const contentEl = document.getElementById('modal-content');

                titleEl.textContent = title;
                contentEl.innerHTML = html;
                modal.style.width = width;
                overlay.style.display = 'flex';
                this.isOpen = true;

                if (window.lucide) window.lucide.createIcons();
            }

            close() {
                console.log(`[ModalManager] Closing modal`);
                const overlay = document.getElementById('plugin-modal-overlay');
                if (overlay) {
                    overlay.style.display = 'none';
                }
                this.isOpen = false;
            }
        }

        // --- Stage Manager ---
        class StageManager {
            setContent(html) {
                console.log(`[StageManager] Setting stage content`);
                const stage = document.getElementById('plugin-area');
                if (stage) {
                    stage.innerHTML = html;
                    if (window.lucide) window.lucide.createIcons();
                }
            }
        }

        // Initialize managers
        const sidebar = new SidebarManager();
        const panels = new PanelManager();
        const toolbar = new ToolbarManager();
        const modal = new ModalManager();
        const stage = new StageManager();

        // Public API for Plugins
        window.ui = {
            // Sidebar
            registerSidebarView: (id, icon, title) => sidebar.registerView(id, icon, title),
            setSidebarContent: (id, html) => sidebar.setContent(id, html),
            toggleSidebar: (id) => sidebar.toggle(id),

            // Panels (GoldenLayout tabs)
            registerPanel: (id, title, icon, position) => panels.registerPanel(id, title, icon, position),
            setPanelContent: (id, html) => panels.setPanelContent(id, html),
            removePanel: (id) => panels.removePanel(id),

            // Toolbar buttons
            registerToolbarButton: (id, icon, title, command) => toolbar.registerButton(id, icon, title, command),

            // Stage content
            setStageContent: (html) => stage.setContent(html),

            // Modal dialogs
            showModal: (title, html, width) => modal.show(title, html, width),
            closeModal: () => modal.close()
        };

        // Sidebar views are registered dynamically by plugins via UI_COMMAND events

        // --- Resize Logic ---
        (function initResize() {
            const panel = document.getElementById('side-panel');
            const handle = document.getElementById('side-panel-resize');
            const mainEditor = document.querySelector('.main-editor');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            handle.addEventListener('mousedown', (e) => {
                if (!panel.classList.contains('open')) return;
                isResizing = true;
                startX = e.clientX;
                startWidth = panel.offsetWidth;
                handle.classList.add('resizing');
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';

                // Prevent iframes from capturing mouse events during resize
                mainEditor.style.pointerEvents = 'none';

                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const delta = e.clientX - startX;
                const newWidth = Math.max(150, Math.min(500, startWidth + delta));
                panel.style.width = newWidth + 'px';

                // Update GoldenLayout during resize for smoother experience
                if (window.myLayout) window.myLayout.updateSize();
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    handle.classList.remove('resizing');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';

                    // Re-enable pointer events on main editor
                    mainEditor.style.pointerEvents = '';

                    // Final GoldenLayout resize
                    if (window.myLayout) {
                        window.myLayout.updateSize();
                    }
                }
            });
        })();


        // --- Layout Config ---
        const config = {
            header: {
                popout: false
            },
            content: [{
                type: 'row',
                content: [
                    {
                        type: 'component',
                        componentName: 'stage',
                        title: 'Stage',
                        width: 65
                    },
                    {
                        type: 'column',
                        width: 35,
                        content: [
                            {
                                type: 'stack',
                                height: 40,
                                content: [
                                    {
                                        type: 'component',
                                        componentName: 'chat',
                                        title: 'LLM Chat'
                                    },
                                    {
                                        type: 'component',
                                        componentName: 'log',
                                        title: 'System Log'
                                    }
                                ]
                            },
                            {
                                type: 'component',
                                componentName: 'controls',
                                title: 'Inspector',
                                height: 20
                            }
                        ]
                    }
                ]
            }]
        };

        const myLayout = new GoldenLayout(config, document.getElementById('layout-root'));

        // --- Component Registration ---
        myLayout.registerComponent('stage', function (container, state) {
            container.element.innerHTML = `
                <div class="panel-container">
                    <div class="scrollable" id="plugin-area">
                        <!-- Default Plugin Area -->
                        <div style="color:var(--text-disabled); text-align:center; margin-top:50px;">
                            Stage Area
                        </div>
                    </div>
                </div>
            `;
        });

        myLayout.registerComponent('chat', function (container, state) {
            container.element.innerHTML = `
                <div class="panel-container">
                    <div class="scrollable" id="chat-area">
                        <div style="color:var(--text-disabled); text-align:center; padding-top:20px;">
                            Waiting for LLM...
                        </div>
                    </div>
                </div>
            `;
        });

        myLayout.registerComponent('log', function (container, state) {
            container.element.innerHTML = `
                <div class="panel-container">
                    <div class="scrollable" id="log-output"></div>
                    <div class="toolbar flex-between">
                        <span class="text-label" style="font-family:var(--font-main);">SYSTEM OUTPUT</span>
                        <button id="clearLog" class="icon-btn" title="Clear Log">
                            Clear
                        </button>
                    </div>
                </div>
            `;

            // Bind Clear Log
            const clearBtn = container.element.querySelector('#clearLog');
            if (clearBtn) {
                clearBtn.onclick = () => {
                    const out = document.getElementById('log-output');
                    if (out) out.innerHTML = '';
                };
            }
        });

        myLayout.registerComponent('controls', function (container, state) {
            container.element.innerHTML = `
                <div class="panel-container">
                    <div class="scrollable">
                        <label class="text-label" style="display:block; margin-bottom:4px; font-weight:600;">COMMAND INPUT</label>
                        <textarea id="cmd-input" rows="3" placeholder="demo.hello"></textarea>
                        
                        <label class="text-label" style="display:block; margin:8px 0 4px 0; font-weight:600;">ARGUMENTS (JSON)</label>
                        <input id="arg-input" placeholder='{"name": "User"}'>
                        
                        <button id="execBtn" class="btn btn-primary" style="width:100%; margin-top:12px;">Execute Command</button>
                    </div>
                </div>
            `;

            // Bind Execute
            const execBtn = container.element.querySelector('#execBtn');
            if (execBtn) {
                execBtn.onclick = async () => {
                    const cmd = document.getElementById('cmd-input').value;
                    let args = {};
                    try {
                        args = JSON.parse(document.getElementById('arg-input').value || '{}');
                        if (typeof args !== 'object' || args === null || Array.isArray(args)) {
                            throw new Error("Arguments must be a JSON object (e.g. {\"key\": \"value\"})");
                        }
                    } catch (e) {
                        log(`Invalid JSON args: ${e.message}`, 'error');
                        return;
                    }

                    try {
                        const res = await request('execute_command', { command: cmd, args: args });
                        log(JSON.stringify(res.result, null, 2));
                    } catch (e) {
                        log(`Exec failed: ${e}`, 'error');
                    }
                };
            }
        });

        myLayout.init();

        window.myLayout = myLayout; // Expose for debugging/resizing

        // Handle Resize
        window.addEventListener('resize', () => {
            if (myLayout.isInitialised) myLayout.updateSize();
        });


        // --- Logic Implementation ---

        let ws = null;
        let rpcId = 0;
        const pending = new Map();

        // Logging
        function log(msg, type = 'info') {
            const out = document.getElementById('log-output');
            if (!out) return;

            const div = document.createElement('div');
            div.className = `log-entry ${type}`;
            const time = new Date().toLocaleTimeString().split(' ')[0];
            div.innerHTML = `<span class="ts">${time}</span>${msg}`;
            out.appendChild(div);
            out.scrollTop = out.scrollHeight;
        }
        window.log = log; // Expose for plugins



        // Connection
        function setConnected(isConnected) {
            const indicator = document.getElementById('conn-status');

            if (isConnected) {
                // indicator.className = 'connected'; // Removed overlay, maybe show in activity bar later?
                log('Connected to Sidecar', 'in');

                // Wait for GoldenLayout to fully initialize and sidecar to be ready
                // Then load plugins with a longer delay
                setTimeout(() => {
                    log('Starting plugin load after delay...', 'info');
                    loadPlugins();
                }, 2000);  // 2 second delay for sidecar init
            } else {
                // indicator.className = 'disconnected';
                log('Disconnected', 'error');
            }
        }

        let reconnectAttempts = 0;
        const maxReconnectAttempts = 10;
        let currentPort = null;

        function connect(explicitPort) {
            // Priority: Explicit Arg > URL param > Default 9002
            let port = explicitPort || currentPort;
            if (!port) {
                const params = new URLSearchParams(window.location.search);
                port = params.get('port') || '9002';
            }
            currentPort = port;  // Save for reconnect

            log(`Connecting to ws://127.0.0.1:${port}... (attempt ${reconnectAttempts + 1}/${maxReconnectAttempts})`);

            ws = new WebSocket(`ws://127.0.0.1:${port}`);

            ws.onopen = () => {
                reconnectAttempts = 0;  // Reset on successful connect
                setConnected(true);
            };

            ws.onclose = () => {
                setConnected(false);
                scheduleReconnect();
            };

            ws.onerror = (e) => {
                log('WebSocket Error', 'error');
                // onclose will be called after onerror, which will trigger reconnect
            };

            ws.onmessage = (e) => {
                try {
                    const data = JSON.parse(e.data);
                    if (data.method === 'trigger_event') {
                        handleEvent(data.params);
                    } else if (data.id && pending.has(data.id)) {
                        pending.get(data.id)(data);
                        pending.delete(data.id);
                    }
                } catch (err) {
                    log(`Parse Error: ${err}`, 'error');
                }
            };
        }

        function scheduleReconnect() {
            if (reconnectAttempts >= maxReconnectAttempts) {
                log(`Max reconnect attempts (${maxReconnectAttempts}) reached. Please reload.`, 'error');
                return;
            }

            reconnectAttempts++;
            // Exponential backoff: 500ms, 1s, 2s, 4s... capped at 5s
            const delay = Math.min(500 * Math.pow(2, reconnectAttempts - 1), 5000);
            log(`Reconnecting in ${delay}ms...`, 'info');

            setTimeout(() => {
                connect();
            }, delay);
        }

        // RPC
        function request(method, params = {}) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('Not connected', 'error');
                return Promise.reject('Not connected');
            }
            return new Promise((resolve) => {
                const id = ++rpcId;
                const msg = { jsonrpc: '2.0', id, method, params };
                pending.set(id, resolve);
                ws.send(JSON.stringify(msg));
                log(`> ${method}`, 'out');
            });
        }
        window.request = request; // Expose for plugins

        // Plugin Loading with retry
        async function loadPlugins(retryCount = 0) {
            const maxRetries = 3;
            const retryDelay = 500; // ms

            try {
                // 0. Notify Backend Client is Ready (Triggers Plugin UI Registration)
                log('Notifying backend: system.client_ready', 'out');
                await request('system.client_ready', {})
                    .catch(e => console.warn('system.client_ready failed', e));

                // Wait for sidecar to finish initializing (longer on first attempt)
                const initDelay = retryCount === 0 ? 1000 : 300;
                await new Promise(resolve => setTimeout(resolve, initDelay));

                // 1. List Commands
                const res = await request('list_commands');
                log(`list_commands response: ${JSON.stringify(res).slice(0, 200)}`, 'in');

                const commands = res.result?.commands || {};
                const commandList = Object.keys(commands);
                log(`Available commands: ${commandList.length}`, 'info');

                // 2. Check for UI commands (convention: *.get_ui)
                const hasLLM = commandList.includes('llm.get_ui');
                log(`Has llm.get_ui: ${hasLLM}`, 'info');

                // If no commands yet and we have retries left, wait and retry
                if (commandList.length === 0 && retryCount < maxRetries) {
                    log(`No commands found, retrying in ${retryDelay}ms... (attempt ${retryCount + 1}/${maxRetries})`, 'info');
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    return loadPlugins(retryCount + 1);
                }

                if (hasLLM) {
                    log('Loading LLM UI...', 'out');
                    const uiRes = await request('execute_command', {
                        command: 'llm.get_ui',
                        args: {}
                    });

                    log(`llm.get_ui response: ${JSON.stringify(uiRes).slice(0, 300)}`, 'in');

                    // Handle various result structures
                    let html = null;

                    // Try different result paths
                    if (uiRes.result?.result?.html) {
                        html = uiRes.result.result.html;
                    } else if (uiRes.result?.html) {
                        html = uiRes.result.html;
                    } else if (uiRes.html) {
                        html = uiRes.html;
                    }

                    if (html) {
                        const stage = document.getElementById('chat-area');
                        if (!stage) {
                            log('Chat pane not found', 'error');
                            return;
                        }
                        // Use createContextualFragment to ensure scripts execute
                        const range = document.createRange();
                        range.selectNode(stage);
                        const fragment = range.createContextualFragment(`<div class="panel-container" style="height:100%;">${html}</div>`);
                        stage.innerHTML = '';
                        stage.appendChild(fragment);

                        // Re-initialize Lucide icons if present
                        if (window.lucide) {
                            window.lucide.createIcons();
                        }

                        log('Loaded LLM UI into Chat Pane', 'in');
                    } else {
                        log('No HTML in llm.get_ui response', 'error');
                    }
                } else if (!hasLLM && retryCount < maxRetries) {
                    // LLM plugin not found, retry
                    log(`LLM plugin not found, retrying... (attempt ${retryCount + 1}/${maxRetries})`, 'info');
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    return loadPlugins(retryCount + 1);
                } else {
                    // No LLM plugin after all retries, show default chat UI
                    const stage = document.getElementById('chat-area');
                    if (stage) {
                        stage.innerHTML = `
                            <div style="text-align:center; padding:40px; color:var(--text-disabled);">
                                <div style="font-size:2rem; margin-bottom:10px;">ðŸ’¬</div>
                                <p>LLM plugin not loaded</p>
                                <p style="font-size:0.8rem;">Enable the LLM plugin in .vault.json</p>
                            </div>
                        `;
                    }
                }

            } catch (e) {
                log(`Plugin Load Error: ${e}`, 'error');
                console.error('loadPlugins error:', e);

                // Retry on error
                if (retryCount < maxRetries) {
                    log(`Retrying after error... (attempt ${retryCount + 1}/${maxRetries})`, 'info');
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    return loadPlugins(retryCount + 1);
                }
            }
        }

        function handleEvent(evt) {
            log(`Event: ${evt.event_type}`, 'in');

            // Dispatch to window (plugins can listen)
            const eventType = evt.event_type; // e.g., 'LLM_RESPONSE'
            const detail = evt.data || {};

            const customEvent = new CustomEvent(eventType, { detail });
            window.dispatchEvent(customEvent);

            // Handle UI Commands from Backend
            if (eventType === 'UI_COMMAND') {
                console.log('[handleEvent] UI_COMMAND received:', evt.data);
                const data = evt.data;

                switch (data.action) {
                    // Sidebar
                    case 'register_sidebar':
                        console.log('[handleEvent] Registering sidebar:', data.id, data.icon, data.title);
                        window.ui.registerSidebarView(data.id, data.icon, data.title);
                        break;
                    case 'set_sidebar':
                        console.log('[handleEvent] Setting sidebar content:', data.id);
                        window.ui.setSidebarContent(data.id, data.html);
                        break;

                    // Panels (GoldenLayout tabs)
                    case 'register_panel':
                        console.log('[handleEvent] Registering panel:', data.id, data.title);
                        window.ui.registerPanel(data.id, data.title, data.icon, data.position);
                        break;
                    case 'set_panel':
                        console.log('[handleEvent] Setting panel content:', data.id);
                        window.ui.setPanelContent(data.id, data.html);
                        break;
                    case 'remove_panel':
                        console.log('[handleEvent] Removing panel:', data.id);
                        window.ui.removePanel(data.id);
                        break;

                    // Toolbar
                    case 'register_toolbar':
                        console.log('[handleEvent] Registering toolbar button:', data.id, data.command);
                        window.ui.registerToolbarButton(data.id, data.icon, data.title, data.command);
                        break;

                    // Stage
                    case 'set_stage':
                        console.log('[handleEvent] Setting stage content');
                        window.ui.setStageContent(data.html);
                        break;

                    // Modal
                    case 'show_modal':
                        console.log('[handleEvent] Showing modal:', data.title);
                        window.ui.showModal(data.title, data.html, data.width);
                        break;
                    case 'close_modal':
                        console.log('[handleEvent] Closing modal');
                        window.ui.closeModal();
                        break;

                    // Input field control (for plugins like prompt refiner)
                    case 'request_input':
                        // Plugin wants the current input text - send it via callback command
                        console.log('[handleEvent] Requesting input for:', data.callback_command);
                        // Try multiple selectors: LLM plugin input, generic chat input
                        const inputEl = document.querySelector('#llm-input, #chat-input, .chat-input, .llm-input');
                        const inputText = inputEl ? inputEl.value : '';
                        console.log('[handleEvent] Found input el:', inputEl, 'text:', inputText);

                        if (data.callback_command && window.request) {
                            window.request(data.callback_command, { text: inputText });
                        }
                        break;
                    case 'set_input':
                        // Plugin wants to set the input field text
                        console.log('[handleEvent] Setting input text:', data.text);
                        // Try multiple selectors: LLM plugin input, generic chat input
                        const targetInput = document.querySelector('#llm-input, #chat-input, .chat-input, .llm-input');
                        console.log('[handleEvent] Found target input:', targetInput);
                        if (targetInput) {
                            targetInput.value = data.text || '';
                            // Trigger input event for any listeners
                            targetInput.dispatchEvent(new Event('input', { bubbles: true }));
                            // Focus the input
                            targetInput.focus();
                            console.log('[handleEvent] Input value set successfully');
                        } else {
                            console.warn('[handleEvent] No input element found!');
                        }
                        break;

                    default:
                        console.warn('[handleEvent] Unknown UI action:', data.action);
                }
            }
        }

        // --- Auto-Connect Logic ---
        (async () => {
            let autoPort = null;

            // 1. Check URL Params (Robustness for new windows)
            const params = new URLSearchParams(window.location.search);
            if (params.has('port')) {
                autoPort = params.get('port');
                log(`Found port in URL: ${autoPort}`);
            }

            // 2. Try Tauri IPC (If launched via Tauri)
            if (!autoPort) {
                try {
                    const { invoke } = await import('@tauri-apps/api/core');
                    const vaultInfo = await invoke('get_current_vault_info');
                    if (vaultInfo && vaultInfo.ws_port) {
                        autoPort = vaultInfo.ws_port;
                        log(`Found port via Tauri: ${autoPort}`);
                    }
                } catch (e) {
                    // Not in Tauri or API failed
                }
            }

            if (autoPort) {
                // Delay slightly to ensure network is ready
                setTimeout(() => connect(autoPort), 300);
            } else {
                log('No auto-connect port found. Connection will use default (9002).');
                // Optional: Auto-connect to default if desired, or just wait
                setTimeout(() => connect('9002'), 300);
            }
        })();

    </script>
</body>

</html>